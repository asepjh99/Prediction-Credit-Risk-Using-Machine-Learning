# -*- coding: utf-8 -*-
"""Copy of FinalTask IDX Prediksi Credit Risk.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1swqk_GQ1aIGui9hz4wdg8EwlqD1EL-9A
"""

# Commented out IPython magic to ensure Python compatibility.
# importing libraries yang dibutuhkan
import pandas as pd
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.datasets import make_blobs
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, roc_curve
from sklearn.model_selection import cross_validate
# %matplotlib inline
import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv('/content/drive/MyDrive/Dataset IDX/loan_data_2007_2014.csv')
df.head(5)

df.info()

"""Kemungkinan kolom yang menunjukan performa dari debitur
- loan_status: Menunjukkan status pinjaman saat ini (misalnya, Fully Paid, Charged Off, Current, dll.).
- total_pymnt: Total pembayaran yang telah dilakukan oleh debitur.
- total_rec_late_fee: Total denda keterlambatan yang diterima.
- recoveries: Jumlah uang yang dipulihkan setelah pinjaman gagal bayar.
- collection_recovery_fee: Biaya pemulihan koleksi.
- last_pymnt_d: Tanggal pembayaran terakhir.
- last_pymnt_amnt: Jumlah pembayaran terakhir.
"""

df.describe()

print(df.isna().sum().to_string())

"""# Feature Selection

- Fitur Unnamed:0, id, member_id,  perlu di drop karena kolom identitas
- fitur desc, title, perlu di drop karena free text
- fitur inq_last_12m, total_cu_tl, inq_fi, all_util, max_bal_bc, open_rv_24m, open_rv_12m, il_util, total_bal_li, mths_since_rcnt_il, open_il_24m, open_il_12m, open_il_6m, open_acc_6m, verification_status_joint, dti_joint, annual_inc_joint, mths_since_last_major_derog, next_pymnt_d, mths_since_last_record, mths_sice_last_delinq perlu di drop karena mengandung banyak sekali missing value
"""

df.drop(columns=['Unnamed: 0', 'id', 'member_id'], inplace=True)

df.drop(columns=['desc', 'title'], inplace=True)

df.drop(columns=['mths_since_last_delinq', 'mths_since_last_record', 'next_pymnt_d', 'mths_since_last_major_derog', 'annual_inc_joint', 'dti_joint', 'verification_status_joint', 'open_acc_6m', 'open_il_6m', 'open_il_12m', 'open_il_24m', 'mths_since_rcnt_il', 'total_bal_il', 'il_util', 'open_rv_12m', 'open_rv_24m', 'max_bal_bc', 'all_util', 'inq_fi', 'total_cu_tl', 'inq_last_12m'], inplace=True)

df.info()

"""# Exloratory Data Analyst ( EDA )

Fitur Numerical
- loan_amnt: Jumlah pinjaman yang diminta oleh peminjam.
- funded_amnt: Jumlah pinjaman yang disetujui untuk peminjam oleh pemberi pinjaman.
- funded_amnt_inv: Jumlah pinjaman yang sebenarnya diberikan kepada peminjam oleh investor (jika berbeda dengan funded_amnt, ini menunjukkan bahwa pinjaman tersebut didanai oleh investor yang berbeda secara parsial).
- int_rate: Tingkat bunga tahunan untuk pinjaman.
- installment: Pembayaran bulanan yang harus dibayarkan oleh peminjam kepada pemberi pinjaman.
- annual_inc: Pendapatan tahunan peminjam.
- dti: Rasio utang terhadap pendapatan (Debt-to-Income ratio), yang merupakan ukuran kemampuan peminjam untuk mengelola pembayaran utangnya.
- delinq_2yrs: Jumlah keterlambatan pembayaran lebih dari 30 hari dalam 2 tahun terakhir.
- inq_last_6mths: Jumlah pertanyaan (inquiry) kredit dalam 6 bulan terakhir.
- open_acc: Jumlah akun kredit terbuka saat ini peminjam.
- pub_rec: Jumlah catatan publik yang muncul dalam riwayat kredit, seperti kebangkrutan, penarikan, atau gugatan.
- revol_bal: Saldo total yang masih harus dibayar pada semua rekening kredit peminjam.
- revol_util: Tingkat penggunaan total dari seluruh kredit yang tersedia.
- total_acc: Jumlah total akun kredit peminjam, termasuk akun terbuka dan tertutup.
- out_prncp: Jumlah pokok pinjaman yang masih belum dibayar.
- out_prncp_inv: Jumlah pokok pinjaman yang masih belum dibayar oleh investor.
- total_pymnt: Jumlah total yang telah dibayar oleh peminjam sampai saat ini.
- total_pymnt_inv: Jumlah total yang telah dibayar oleh peminjam sampai saat ini kepada investor.
- total_rec_prncp: Total pokok pinjaman yang telah diterima kembali oleh pemberi pinjaman atau investor.
- total_rec_int: Total bunga yang telah diterima kembali oleh pemberi pinjaman atau investor.
- total_rec_late_fee: Total denda keterlambatan yang telah diterima kembali.
- recoveries: Jumlah dana yang dikumpulkan dari peminjam setelah gagal bayar.
- collection_recovery_fee: Biaya pemulihan yang dibebankan kepada peminjam sebagai hasil dari proses pemulihan dana.
- last_pymnt_amnt: Jumlah terakhir yang dibayarkan oleh peminjam sesuai dengan jadwal pembayaran.
- collections_12_mths_ex_med: Jumlah koleksi yang dilaporkan dalam 12 bulan terakhir, tidak termasuk medis.
- policy_code: Kode internal yang digunakan untuk identifikasi produk pinjaman.
- acc_now_delinq: Jumlah akun saat ini yang sedang terlambat dalam pembayaran.
- tot_coll_amt: Jumlah total tagihan yang tertunda untuk pengumpulan.
- tot_cur_bal: Total saldo saat ini untuk semua rekening yang diperlakukan oleh kreditur.
- total_rev_hi_lim: Total batas kredit tinggi untuk semua rekening yang diperlakukan oleh kreditur.
"""

df.describe()

"""- fitur policy_code hanya mempunyai 1 nilai unique (konstan) perlu di drop"""

df.drop(columns=['policy_code'],inplace=True)

col_numeric = df.select_dtypes(include=['int64', 'float64']).columns.tolist()

# Buat figure dan axis
fig, axes = plt.subplots(nrows=6, ncols=6, figsize=(15, 12))

# Flatten axes array untuk iterasi yang lebih mudah
axes = axes.flatten()

# Loop melalui semua fitur numerik
for i in range(len(col_numeric)):
    sns.distplot(df[col_numeric[i]], color='gray', ax=axes[i])
    axes[i].set_title(col_numeric[i])

# Jika ada subplot yang tidak digunakan, hapus axis
for i in range(len(col_numeric), len(axes)):
    fig.delaxes(axes[i])

# Menyesuaikan tata letak
plt.tight_layout()

# Menampilkan plot
plt.show()

#Cek menggunakan Boxplot
plt.figure(figsize=(12, 12))

# Loop untuk membuat subplot untuk setiap kolom numerik
for i in range(len(col_numeric)):
    plt.subplot(6, 6, i+1)  # Ubah angka 3 dan 2 untuk membuat grid 3 baris x 2 kolom
    sns.boxplot(y=df[col_numeric[i]], color='gray', orient='v')
    plt.tight_layout()

plt.show()

# Menghitung matriks korelasi
correlation_matrix = df[col_numeric].corr()

# Membuat heatmap untuk visualisasi matriks korelasi
plt.figure(figsize=(25, 25))
sns.heatmap(correlation_matrix, annot=True, fmt='.2f', cmap='coolwarm', linewidths=0.5)
plt.title('Matriks Korelasi Fitur Numerik')
plt.show()

# Drop fitur yang memiliki korelasi tinggi
df.drop(columns=['funded_amnt', 'funded_amnt_inv', 'installment', 'total_pymnt_inv'], inplace=True)

#Fitur Kategorical
cats = df.select_dtypes(include=['object']).columns.tolist()

"""- term: Jangka waktu pinjaman, misalnya "36 months" atau "60 months".
- grade: Peringkat kredit yang diberikan oleh pemberi pinjaman, misalnya A, B, C, dll.
- sub_grade: Sub-peringkat kredit yang lebih detail, misalnya A1, A2, ..., B1, B2, dll.
- emp_title: Jabatan atau nama pekerjaan peminjam.
- emp_length: Lamanya masa kerja peminjam dalam tahun.
- home_ownership: Status kepemilikan rumah peminjam, misalnya "OWN", "RENT", atau "MORTGAGE".
- verification_status: Status verifikasi pendapatan peminjam, misalnya "Verified", "Not Verified", atau "Source Verified".
- issue_d: Tanggal pencairan pinjaman.
- loan_status: Status pinjaman, apakah "Fully Paid" (lunas) atau "Charged Off" (gagal bayar).
- pymnt_plan: Apakah peminjam memiliki rencana pembayaran.
- url: URL aplikasi pinjaman.
- purpose: Tujuan dari pinjaman, misalnya "debt_consolidation", "credit_card", atau "home_improvement".
- title: Judul pinjaman yang diberikan oleh peminjam.
- zip_code: Kode pos tempat tinggal peminjam (hanya beberapa digit pertama).
- addr_state: Negara bagian tempat tinggal peminjam.
- earliest_cr_line: Tanggal pembukaan akun kredit pertama peminjam.
- initial_list_status: Status awal pendaftaran pinjaman.
- last_pymnt_d: Tanggal pembayaran terakhir.
- last_credit_pull_d: Tanggal terakhir pengambilan data kredit.
- application_type: Jenis aplikasi pinjaman, misalnya "Individual" atau "Joint".

-


"""

df[cats].describe()

"""- fitur sub_grade, url, zip_code, addr_state perlu di drop, karena mempunyai high cardinality
- fitur application_type perlu di drop karena memiliki 1 nilai unique (konstan)
- fitur denga datetime seperti, issue_d, earliest_cr_line, last_pymnt_d, last_credit_pull_d , perlu dilakukan ekstraksi lebih lanjut.
"""

df.drop(columns=['zip_code', 'url', 'addr_state', 'application_type', 'sub_grade'], inplace=True)

"""# Feature Extraxtion"""

df_fe = df.copy()

#Fitur Kategorical
cats = df_fe.select_dtypes(include=['object']).columns.tolist()

df_fe[cats].describe()

df_fe.drop(columns=['emp_title'], inplace=True)

# Mapping Home Ownership
mapping_home = {
    'MORTGAGE' : 'MORTGAGE',
    'RENT' : 'RENT',
    'OWN' : 'OWN',
    'OTHER' : 'RENT',
    'NONE' : 'RENT',
    'ANY' : 'RENT'
}
df_fe['home_ownership'] = df_fe['home_ownership'].map(mapping_home)

# Mengubah kolom tanggal menjadi datetime
date_columns = ['issue_d', 'earliest_cr_line', 'last_pymnt_d', 'last_credit_pull_d']

# Memeriksa beberapa baris dari kolom tanggal
print(df_fe[['issue_d', 'earliest_cr_line', 'last_pymnt_d', 'last_credit_pull_d']].head(10))

# Mengubah tipe data menjadi datetime
for col in date_columns:
    df_fe[col] = pd.to_datetime(df_fe[col], format='%b-%y', errors='coerce')

# Mengekstraksi tahun dan bulan dari kolom-kolom tersebut
for col in date_columns:
    df_fe[f'{col}_year'] = df_fe[col].dt.year
    df_fe[f'{col}_month'] = df_fe[col].dt.month

# Mengonversi emp_length menjadi nilai numerik
def extract_years(emp_length):
    if pd.isnull(emp_length):
        return None
    elif emp_length == '< 1 year':
        return 0
    elif emp_length == '10+ years':
        return 10
    else:
        return int(emp_length.split()[0])

df_fe['emp_length'] = df_fe['emp_length'].apply(extract_years)

df_fe.info()

"""- drop fitur datetime yang sudah di ekstraksi"""

df_fe.drop(columns=['issue_d', 'earliest_cr_line', 'last_pymnt_d', 'last_credit_pull_d'], inplace=True)

df_fe.info()

"""# GOOD OR BAD"""

df_fe['loan_status'].value_counts()

# Mengkategorikan debitur sebagai GOOD atau BAD berdasarkan loan_status
def categorize_debtor(status):
    if status in ['Fully Paid', 'Current', 'Does not meet thecredit policy. Status:Fully Paid']:
        return 'GOOD'
    elif status in ['Charged Off', 'Default', 'Late (31-120 days)', 'Late (16-30 days)', 'In Grace Period']:
        return 'BAD'
    else:
        return None

# Menerapkan fungsi ke kolom loan_status
df_fe['borrowed_status'] = df_fe['loan_status'].apply(categorize_debtor)

# Menampilkan hasil
print(df_fe[['loan_status', 'borrowed_status']].head())

df_fe['borrowed_status'].value_counts()

"""## Bivariate Analysis"""

#Melihat hubungan antara Delinnquencies dan Loan_status
# Filter data hanya untuk loan_status yang relevan
relevant_statuses = ['Fully Paid', 'Charged Off', 'Current', 'Default',
                     'Late (31-120 days)', 'In Grace Period', 'Late (16-30 days)',
                     'Does not meet the credit policy. Status:Fully Paid',
                     'Does not meet the credit policy. Status:Charged Off']
filtered_df = df_fe[df_fe['loan_status'].isin(relevant_statuses)]

# Buat box plot
plt.figure(figsize=(12, 8))
sns.boxplot(x='loan_status', y='delinq_2yrs', data=filtered_df)
plt.title('Distribusi Delinquencies dalam 2 Tahun berdasarkan Loan Status')
plt.xlabel('Loan Status')
plt.ylabel('Delinquencies dalam 2 Tahun')
plt.xticks(rotation=45, ha='right')
plt.grid(True)

# Tampilkan plot
plt.tight_layout()
plt.show()

#Melihat hubungan antara permintaan kredit 6 bulan terakhir dan Loan_status
# Filter data hanya untuk loan_status yang relevan
relevant_statuses = ['Fully Paid', 'Charged Off', 'Current', 'Default',
                     'Late (31-120 days)', 'In Grace Period', 'Late (16-30 days)',
                     'Does not meet the credit policy. Status:Fully Paid',
                     'Does not meet the credit policy. Status:Charged Off']
filtered_df = df_fe[df_fe['loan_status'].isin(relevant_statuses)]

# Buat box plot
plt.figure(figsize=(12, 8))
sns.boxplot(x='loan_status', y='inq_last_6mths', data=filtered_df)
plt.title('Distribusi permintaan kredit 6 bulan terakhir berdasarkan Loan Status')
plt.xlabel('Loan Status')
plt.ylabel('permintaan kredit 6 bulan terakhir')
plt.xticks(rotation=45, ha='right')
plt.grid(True)

# Tampilkan plot
plt.tight_layout()
plt.show()

# Menggunakan seaborn untuk membuat plot
plt.figure(figsize=(20, 6))
sns.countplot(data=df_fe, x='purpose', hue='loan_status')
plt.title('Loan Status Distribution by purpose')
plt.xlabel('Tujuan Peminjaman')
plt.ylabel('Count')
plt.legend(title='Loan Status')
plt.show()

# Membuat countplot untuk earliest_cr_line_month
plt.figure(figsize=(10, 6))
sns.countplot(data=df_fe, x='earliest_cr_line_month', palette='viridis')
plt.title('Jumlah Pembukaan Kredit Pertama berdasarkan Bulan')
plt.xlabel('Bulan')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

"""- Bulan Oktober merupakan bulan dengan jumlah pembukaan kredit pertama terbanyak"""

# Menghitung jumlah pinjaman per tahun
loan_counts_per_year = df_fe['issue_d_year'].value_counts().sort_index()

# Membuat line plot untuk jumlah pinjaman per tahun
plt.figure(figsize=(10, 6))
loan_counts_per_year.plot(kind='line', marker='o')
plt.title('Jumlah Pinjaman Berdasarkan Tahun')
plt.xlabel('Tahun')
plt.ylabel('Jumlah Pinjaman')
plt.grid(True)
plt.show()

"""- Jumlah pinjaman terus mengalami peningkatan-peningkatan dari tahun ke tahun"""

# Membuat bar plot menggunakan Seaborn
plt.figure(figsize=(10, 6))
sns.countplot(data=df_fe, x='home_ownership', hue='borrowed_status')
plt.title('Hubungan antara Credit Status dengan Home Ownership')
plt.xlabel('Borrowed Status')
plt.ylabel('Jumlah')
plt.show()

# Menghitung cross-tabulation antara credit_status dan term
cross_tab = pd.crosstab(df_fe['borrowed_status'], df_fe['term'])

# Plot heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(cross_tab, annot=True, cmap='YlGnBu', cbar=True, linewidths=.5, fmt='d')
plt.title('Relationship between Credit Status and Loan Term')
plt.xlabel('Term')
plt.ylabel('borrowed_status')
plt.show()

# Credit Status berdasarkan lama bekerja
plt.figure(figsize=(10, 6))
sns.countplot(data=df_fe, x='emp_length', hue='borrowed_status')
plt.title('Hubungan antara Borrowed Status dengan Panjang Masa Kerja (Emp Length)')
plt.xlabel('Panjang Masa Kerja (Emp Length)')
plt.ylabel('Jumlah')
plt.show()

"""## Handling Missing Value"""

df_fe.drop(columns=['loan_status'], inplace=True)

df_prep = df_fe.copy()

df_prep.isna().sum()

df_prep.describe()

"""- drop baris kolom yang memiliki missing value yang banyak, karena apabila kita melakukan imputasi ditakutkan akan menyebabkan perubahan distribusi"""

df_prep.dropna(subset=['tot_coll_amt', 'tot_cur_bal', 'total_rev_hi_lim'], inplace=True)

df_prep.dropna(subset=['emp_length'], inplace=True)

df_prep.dropna(subset=['revol_util', 'last_pymnt_d_year', 'last_pymnt_d_month', 'last_credit_pull_d_year', 'last_credit_pull_d_month'], inplace=True)

df_prep.info()

"""## Handling Outliers"""

col_numeric = df_prep.select_dtypes(include=['int64', 'float64']).columns.tolist()

# Handling Outliers menggunakan Z-Score
# Filter Outlier
print(f'Jumlah baris sebelum memfilter outlier: {len(df_prep)}')

filtered_entries = np.array([True] * len(df_prep))
for col in col_numeric:
    zscore = np.abs(stats.zscore(df_prep[col]))  # Menghitung absolute Z-score
    filtered_entries = filtered_entries & (zscore < 3)

df_prep = df_prep[filtered_entries]

print(f'Jumlah baris setelah memfilter outlier: {len(df_prep)}')

col_numeric = df_prep.select_dtypes(include=['int64', 'float64']).columns.tolist()

#Cek Outlier menggunakan Boxplot
plt.figure(figsize=(12, 12))

# Loop untuk membuat subplot untuk setiap kolom numerik
for i in range(len(col_numeric)):
    plt.subplot(6, 6, i+1)  # Ubah angka 3 dan 2 untuk membuat grid 3 baris x 2 kolom
    sns.boxplot(y=df_prep[col_numeric[i]], color='gray', orient='v')
    plt.tight_layout()

plt.show()

df_prep.drop(columns=['collections_12_mths_ex_med', 'acc_now_delinq'], inplace=True)

"""# Feature Encoding"""

# Ubah fitur term menjadi numerik
# Menghapus kata "months" dan mengonversi ke numerik
df_prep['term'] = df_prep['term'].str.replace(' months', '').astype(int)

#Fitur Kategorical
cats = df_prep.select_dtypes(include=['object']).columns.tolist()

df_prep[cats].describe()

"""- Label Encoding untuk fitur grade, pymnt_plan, initial_list_status dan credit_status
- One Hot Encoding untuk home_ownership, verification_status dan purpose
"""

# Label Encoding untuk fitur grade
mapping_grade = {
    'A' : 0,
    'B' : 1,
    'C' : 2,
    'D' : 3,
    'E' : 4,
    'F' : 5,
    'G' : 6
}
df_prep['grade'] = df_prep['grade'].map(mapping_grade)

# Label Encoding untuk pymnt_plan
mapping_pp = {
    'n' : 0,
    'y' : 1
}
df_prep['pymnt_plan'] = df_prep['pymnt_plan'].map(mapping_pp)

# Label Encoding untuk initial_list_status
mapping_ils = {
    'f' : 0,
    'w' : 1
}
df_prep['initial_list_status'] = df_prep['initial_list_status'].map(mapping_ils)

# Label Encoding untuk Credit Status
mapping_bs = {
    'BAD' : 0,
    'GOOD' : 1
}
df_prep['borrowed_status'] = df_prep['borrowed_status'].map(mapping_bs)

df_prep['borrowed_status'].value_counts()

# One Hot Encoding untuk fitur home_ownership, verification_status, dan purpose
df_prep = pd.get_dummies(df_prep, columns=['home_ownership'])
df_prep = pd.get_dummies(df_prep, columns=['verification_status'])
df_prep = pd.get_dummies(df_prep, columns=['purpose'])

# Mengidentifikasi kolom boolean
boolean_columns = df_prep.select_dtypes(include='bool').columns

# Mengubah tipe data boolean menjadi integer
df_prep[boolean_columns] = df_prep[boolean_columns].astype(int)

df_prep.info()

df_prep

corr_matrix = df_prep.corr()

# Menampilkan matriks korelasi menggunakan seaborn heatmap
plt.figure(figsize=(30, 30))  # Ukuran plot disesuaikan
sns.heatmap(corr_matrix, annot=True, fmt=".2f", cmap='coolwarm', cbar=True, square=True)
plt.title('Correlation Matrix')
plt.show()

"""- Drop fitur yang memiliki korelasi tinggi ( int_rate:, total_pymnt, out_prncp )"""

df_prep.drop(columns=['int_rate', 'total_pymnt'], inplace=True)

df_prep.drop(columns=['out_prncp'], inplace=True)

df_prep['borrowed_status'] = df_prep.pop('borrowed_status')

corr_matrix = df_prep.corr()
# Menampilkan matriks korelasi menggunakan seaborn heatmap
plt.figure(figsize=(30, 30))  # Ukuran plot disesuaikan
sns.heatmap(corr_matrix, annot=True, fmt=".2f", cmap='coolwarm', cbar=True, square=True)
plt.title('Correlation Matrix')
plt.show()

# Identifikasi korelasi tinggi
threshold = 0.9
high_corr_var = np.where(np.abs(corr_matrix) > threshold)
high_corr_var = [(corr_matrix.index[x], corr_matrix.columns[y])
                 for x, y in zip(*high_corr_var) if x != y and x < y]

print("Fitur-fitur dengan korelasi tinggi (di atas 0.9):")
print(high_corr_var)

"""- Dilakukan drop untuk fitur yang memiliki korelasi yang tinggi (<0.9), fitur yang akan di drop yaitu fitur ['loan_amnt', 'funded_amnt_inv', installment, int_grade, out_prncp, total_pymnt, total_rec_prncp]
- dilakukan drop juga untuk salah satu fitur hasil dari One-Hot Encoding, antara hasil pertama atau hasil terakhir

"""

df_prep.drop(columns=['home_ownership_MORTGAGE', 'verification_status_Not Verified', 'purpose_car'], inplace=True)

from statsmodels.stats.outliers_influence import variance_inflation_factor
# Ambil kolom fitur dari df_prep (pastikan tidak termasuk kolom target)
features = df_prep.drop(columns=['borrowed_status'])

# Tambahkan sebuah kolom constant untuk menghitung VIF
features['Intercept'] = 1

# Inisialisasi dataframe untuk menyimpan hasil VIF
vif_data = pd.DataFrame()
vif_data['Feature'] = features.columns
vif_data['VIF'] = [variance_inflation_factor(features.values, i) for i in range(features.shape[1])]

# Tampilkan hasil VIF
print(vif_data)

vif_data

"""- Berdasarkan VIF Checking, terdapat beberapa fitur yang memiliki nilai VIF > 5 yaitu fitur purpose_other, purpose_home_improvement, last_pymnt_d_year, total_rev_hi_lim, total_rec_int, revol_bal"""

df_prep.drop(columns=['purpose_other', 'purpose_home_improvement', 'last_pymnt_d_year', 'total_rev_hi_lim', 'total_rec_int', 'revol_bal', 'out_prncp_inv'], inplace=True)

df_prep.info()

"""# Standarisasi"""

df_s = df_prep.copy()

df_s.info()

# Standarisasi menggunakan StandardScaler
scaler_standard = StandardScaler()

columns_to_scale = ['last_credit_pull_d_month', 'last_credit_pull_d_year', 'last_pymnt_d_month', 'issue_d_month', 'issue_d_year', 'tot_cur_bal', 'tot_coll_amt', 'last_pymnt_amnt', 'collection_recovery_fee', 'recoveries', 'total_rec_late_fee', 'total_rec_prncp', 'initial_list_status', 'total_acc', 'revol_util', 'pub_rec', 'open_acc', 'inq_last_6mths', 'delinq_2yrs', 'dti', 'annual_inc', 'emp_length', 'grade', 'term', 'loan_amnt']

# Standarisasi kolom yang dipilih
df_s[columns_to_scale] = scaler_standard.fit_transform(df_s[columns_to_scale])

df_s.head()

"""# Oversampling"""

df_model = df_s.copy()

X = df_model.drop(columns=['borrowed_status'])
y = df_model['borrowed_status']

# Membagi data menjadi training dan test set
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

X_train.shape, X_test.shape, y_train.shape, y_test.shape

# Lakukan oversampling menggunakan SMOTE pada training set
smote = SMOTE(random_state=42)

# Oversampling
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

# Print formatted comparison
print("Data Distribution Before Oversampling:")
print(f"  Total samples: {len(df_model)}")
print(f"  Count (borrowed_status = 0): {y.value_counts()[0]}")
print(f"  Count (borrowed_status = 1): {y.value_counts()[1]}")

print("Data Distribution After Oversampling:")
print(f"  Total samples: {len(X_train_resampled)}")
print(f"  Count (borrowed_status = 0): {y_train_resampled.value_counts()[0]}")
print(f"  Count (borrowed_status = 1): {y_train_resampled.value_counts()[1]}")

"""# Modeling"""

# evaluasi model
def eval_classification(model):
    y_pred = model.predict(X_test)
    y_pred_train = model.predict(X_train_resampled)
    y_pred_proba = model.predict_proba(X_test)
    y_pred_proba_train = model.predict_proba(X_train_resampled)

    #Dilakukan tuning F1 dengan menghilangkan perhitungan recall
    print("Accuracy (Test Set): %.4f" % accuracy_score(y_test, y_pred))
    print("Precision (Test Set): %.4f" % precision_score(y_test, y_pred))
    print("F1-Score (Test Set): %.4f" % f1_score(y_test, y_pred))
    print("Recall (Test Set): %.4f" % recall_score(y_test, y_pred))
    print("ROC AUC (Train-proba): %.4f" % roc_auc_score(y_train_resampled, y_pred_proba_train[:, 1]))
    print("ROC AUC (Test-proba): %.4f" % roc_auc_score(y_test, y_pred_proba[:, 1]))

    # Cross-validation dengan precision sebagai metrik
    score = cross_validate(model, X_train_resampled, y_train_resampled, cv=10, scoring='precision', return_train_score=True)
    print('Precision (crossval train): '+ str(score['train_score'].mean()))
    print('Precision (crossval test): '+ str(score['test_score'].mean()))

# Logistic Regression
lr = LogisticRegression(class_weight='balanced', random_state=42)
lr.fit(X_train_resampled, y_train_resampled)
eval_classification(lr)

# DecisionTree
dt = DecisionTreeClassifier(max_depth=10, min_samples_split=2, min_samples_leaf=1, max_features=None, criterion='gini', random_state=42)
dt.fit(X_train_resampled, y_train_resampled)
eval_classification(dt)

"""# Confusion Matrix"""

# Function to plot confusion matrix
def plot_confusion_matrix(y_true, y_pred, model_name):
    cm = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.title(f'Confusion Matrix for {model_name}')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

# Evaluasi dan plot confusion matrix untuk Logistic Regression
plot_confusion_matrix(y_test, lr.predict(X_test), "Logistic Regression")

# Evaluasi dan plot confusion matrix untuk Decision Tree
plot_confusion_matrix(y_test, dt.predict(X_test), "Decision Tree")

